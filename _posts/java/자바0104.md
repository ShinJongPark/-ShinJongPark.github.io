javac.exe로 컴파일 시 주석은 제외하고 컴파일 한다.

저장버튼을 누르면 자동으로 컴파일 되며, 실행시 내부적으로 java.exe가 실행되고, jvm은 컴파일된 바이트 코드를 실행한다.

워크스페이스의 .metadata는 이클립스의 속성값을 저장하며, 이전의 작업 환경을 복원할 목적으로 사용한다.

이클립스 초기상태로 되돌리고자 한다면 .metadata 파일을 삭제하고 재시작하면 된다.

소스 코드 내에서 직접 입력된 값을 리터럴(literal)이라고 부른다.

정수 리터럴에서 0으로 시작하면 8진수, 0x or 0X 로 시작하면 16진수로 간주한다.

실수 리터럴에서 5E3 은 5의 3승을 의미하며, 0.12E-5는 0.12의 -5승으로 간주한다. float, double에 저장할 수 있다.



변수 이름에 첫 글자 문자에 '$' 또는 '_'가 올 수 있다.

char 타입은 자바에서 유니코드로 처리하며, 0~65535 범위의 2byte 크기를 가진 정수값이다. bit mask에서 많이 사용했던 것 같음.

A는 16진수로 65이며 16진수로 '\u0041' 로 저장할 수 있다. '\u + 16진수값' 형태로 저장할 수 있다.

long 타입에서 데이터를 초기화할 때 int 의 범위를 초과하면 숫자 끝에 소문자 l 또는 대문자 L을 붙여야 한다.

자바에서는 실수 리터럴 기본 타입을 double로 간주한다. 따라서 실수 리터럴을 float 타입으로 저장하기 위해서는 리터럴 뒤에 소문자 f 또는 대문자 F를 붙여야 한다.

타입 변환에는 자동(묵시적) 타입 변환과 강제(명시적) 타입 변환이 있다.

자동(묵시적) 타입 변환 : 작은 크기 타입의 데이터를 큰 크기 타입의 변수에 저장할때 자동(묵시적) 타입 변환이 일어난다.

강제(명시적) 타입 변환 : 큰 크기 타입의 데이터를 작은 크기 타입의 변수에 저장할때 캐스팅 연산자를 사용한다.

저장할때 변수 타입보다 큰 데이터를 저장하면, 변수 타입의 비트를 제외하고 삭제한다. 즉, 해당 저장변수 비트공간에만 저장한다.

ex) 1010111 10000000(2Byte) => 10000000(1Byte) 저장

Int 타입은 char 타입으로 자동 변환되지 않기 때문에 강제 타입 변환을 사용해야 한다.

실수 타입(float, double)은 정수 타입(byte, short, int, long)으로 자동 변환되지 않기 때문에 강제 타입 변환을 사용해야 한다.

소수 부분은 버려지고 정수 부분만 저장.

연산식에서 피연산자의 타입이 다르면 큰 타입으로 자동 변환된 후 수행한다.



부호 연산자를 사용하면 산출 타입은 int 형이다.

short 타입에 값에 부호를 추가하면 short가 아닌 int 타입으로 변한다.

```java
short s = 100;
short result = -s;	// 에러 발생
int reseult - -s;		// 이렇게 저정 해야함.
```



++i 가 i=i+1 보다 빠르게 연산되지 않는다. 소스 코드를 컴파일 하면 동일한 바이트 코드가 생성된다.

```java
public static void main(String[] args) {
  int s = 1;
  System.out.println(++s);
  System.out.println(s=s+1);
}
```

소스 코드를 바이트 코드로 컴파일한 것이다.

```
public static void main(java.lang.String[] args);
     0  iconst_1
     1  istore_1 [s]
     2  getstatic java.lang.System.out : java.io.PrintStream [18]
     5  iinc 1 1 [s]
     8  iload_1 [s]
     9  invokevirtual java.io.PrintStream.println(int) : void [24]
    12  getstatic java.lang.System.out : java.io.PrintStream [18]
    15  iinc 1 1 [s]
    18  iload_1 [s]
    19  invokevirtual java.io.PrintStream.println(int) : void [24]
    22  return
```

5~18 라인에서 볼수 있듯이 동일하다.



비트 반전 연산자(~)도 산출물이 int 타입이다.

비트 반전 연산자 사용시 비트 연산자도 반전되기 때문에 산출값에 1을 더하면 반대값을 얻을 수 있다.

자바는 32비트의 이진 문자열로 리턴하는 Integer.toBinaryString() 메소드를 제공한다.

앞에 0이 제거된 상태로 리턴된다.

자바에서 기본 연산을 JVM에서 32비트로 수행하기 때문에 int 타입으로 나온다.



일반 논리 연산자

boolean 논리 연산자에서는 보통 & 보다 &&, | 보다 || 을 사용하며, 첫번째 피연산자를 통해 두번째 피연산자를 수행여부를 판단한다. &&, ||이 효과적이다.

비트 논리 연산자

&, |, ^, ~를 포함하며, 피연산자가 boolean 이라면 일반 논리 연산자, 정수라면 비트 논리 연산자로 구분된다.

비트 연산 역시 int 타입에 저장한다. 





JVM은 운영체제에서 할당받은 메모리 영역을 세부 영역으로 구분해서 사용한다.

### 메소드 영역.

~.class들은 클래스 로더로 읽어 클래스별로 런타임 상수풀, 필드 데이터, 메소드 코드, 생성자 코드 등을 분류해서 저장한다. 메소드 영역은 JVM이 시작할 때 생성되고 모든 스레드가 공유하는 영역이다.

### 힙 영역

힙 영역은 객체와 배열이 생성되는 영역이다.힙 영역에서 생성된 객체와 배열은 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조한다. 참조하는 변수나 필드가 없다면 의미 없는 객체가 생성되기 때문에 이것을 가비지 컬렉터를 실행시켜 힙 영역에서 자동으로 제거한다. 그렇기 때문에 개발자는 객체를 제거하기 위해 별도의 코드를 작성할 필요가 없다.

자바는 객체를 직접 제거하는 방법을 제공하지 않는다.

### JVM 스택 영역

JVM 스택 영역은 스레드마다 하나씩 생성되며, 추가로 생성하지 않았다면 main 스레드만 존재하므로 JVM 스택도 하나다.

메소드를 호출할 때마다 프레임(frame)을 추가하고 메소드가 종료되면 해당 프레임을 제거하는 동작을 수행한다.

예외 발생시 printStackTrace() 메소드로 보여주는 Stack Trace의 각 라인은 하나의 프레임을 표현한다.

프레임 내부에는 로컬 변수 스택이 있는데, 기본 타입 변수와 참조 타입 변수가 추가되거나 제거된다.

변수가 이 영역에 생성되는 시점은 초기화가 될 때, 변수는 선언된 블록 안에서만 스택에 존재하고 블록을 벗어나면 스택에서 제거된다.

블록에서 생성된 기본 타입 변수는 직접 값을 스택에 가지고 있지만, 참조타입 변수는 힙 영역에 저장된다.